#pragma once


#include <memory>
#include <pcl/point_cloud.h>

#include "E57Format.h"
#include "nlohmann/json.hpp"

#include "Common.h"
#include "PointType.h"

namespace e57
{
	std::string NodeTypeStr(NodeType t);

	void ParseNode(std::size_t pDepth, const e57::StructureNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::VectorNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::CompressedVectorNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::IntegerNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::ScaledIntegerNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::FloatNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::StringNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::BlobNode& pNode);

	void ParseNode(std::size_t pDepth, const e57::Node& pNode);

	void PrintFormat(const boost::filesystem::path& e57Path);

	class ScanInfo
	{
	public:
		Scanner scanner;
		CoodSys coodSys;
		RAEMode raeMode; // only avalible when coodSys is RAE
		Eigen::Matrix4d transform;
		Eigen::Quaterniond orientation; // cache from transform
		Eigen::Vector3d position; // cache from transform
		bool hasPointXYZ;
		bool hasPointRGB;
		bool hasPointI;
		std::size_t ID;
		std::size_t numPoints;
		std::size_t numValidPoints;

		ScanInfo(
			Scanner scanner = Scanner::Scaner_UNKNOWN, CoodSys coodSys = CoodSys::CoodSys_UNKNOWN, RAEMode raeMode = RAEMode::RAEMode_UNKNOWN,
			Eigen::Matrix4d transform = Eigen::Matrix4d::Identity(),
			bool hasPointXYZ = false, bool hasPointRGB = false, bool hasPointI = false,
			std::size_t ID = 0, std::size_t numPoints = 0, std::size_t numValidPoints = 0)
			: scanner(scanner),  coodSys(coodSys), raeMode(raeMode),
			transform(transform), orientation(Eigen::Quaterniond(0.0, 0.0, 0.0, 0.0)), position(Eigen::Vector3d(0.0, 0.0, 0.0)),
			hasPointXYZ(hasPointXYZ), hasPointRGB(hasPointRGB), hasPointI(hasPointI),
			ID(ID), numPoints(numPoints), numValidPoints(numValidPoints) {}

		nlohmann::json DumpToJson();
		static ScanInfo LoadFromJson(const nlohmann::json& j);
	};

	class Scan : public ScanInfo
	{
	public:
		std::shared_ptr<float> x;
		std::shared_ptr<float> y;
		std::shared_ptr<float> z;
		std::shared_ptr<float> i;
		std::shared_ptr<uint8_t> r;
		std::shared_ptr<uint8_t> g;
		std::shared_ptr<uint8_t> b;

		Scan(Scanner scanner = Scanner::Scaner_UNKNOWN) : ScanInfo(scanner) {}

		void Load(const e57::ImageFile& imf, const e57::VectorNode& data3D, int64_t scanID);

		// minRGB: Mean a point will be kept only if one of R, G, B is larger than minRGB, This parameters is to filter out the black noise which is generated by some scanner (such as BLK360).
		void ExtractValidPointCloud(pcl::PointCloud<PointE57>& scanCloud, const uint8_t minRGB);

		operator ScanInfo() const
		{
			return ScanInfo(scanner, coodSys, raeMode, transform, hasPointXYZ, hasPointRGB, hasPointI, ID, numPoints, numValidPoints);
		}
	};
}